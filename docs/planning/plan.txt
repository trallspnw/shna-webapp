Notes on key design choices
Identity & privacy model (implemented as a pattern)

We treat “identity” as a mode per record (not a single global enum):

Identified: record links to contacts (email stored; used for membership + comms).

Alias (future): record links to aliases (pseudonymous, no email).

Anonymous: record has no identity link (and in a few cases uses an aggregate counter).

Option A (selected): If user checks Stay anonymous on donation/retail, we do not:

link to an existing contact

store their email/name

update engagement timestamps on any contact

We still store Stripe ids + amounts + attribution for reconciliation and analytics.

Why membershipTerms exists

membershipPlans = “what you sell”
membershipAccounts = “who it applies to”
membershipTerms = “when coverage is valid (and for how much)”

Each renewal creates a new term, enabling:

clean renewals and plan switching (household → individual, etc.)

audit history (refunds, comped terms, pricing changes)

simple “is active?” query by date range

Anonymous members on membership accounts

To avoid child PII and reduce rigidity:

secondary members can be contacts (adult household members)

plus anonymousMemberCount for unnamed members

(optionally later) aliases for pseudonymous named members

Events + attendance

events is canonical and powers public pages and analytics.

eventAttendances is mostly one row per attendee, except anonymous can be a single aggregate row via anonymousCount.

We intentionally avoid partySize for now (preference: individual sign-ins).

Draft data flows
A) Membership purchase (requires Contact)

User fills membership form (email required).

System upserts contacts (normalized email; language set based on current site language).

System creates or updates membershipAccounts:

set primaryContact

optionally add secondaryContacts

optionally set anonymousMemberCount

System creates Stripe checkout session.

Webhook on success:

create transactions (kind=membership, paymentMethod=stripe, status=paid)

create membershipTerms:

startsAt = now OR existing term’s expiresAt (if renewing)

expiresAt = startsAt + durationMonths

snapshot planKeySnapshot, pricePaidUSD

link transactionId

Membership verification uses contacts.email → latest active membershipTerms for that contact’s account.

B) Membership renewal + plan switching

User triggers renewal within renewal window.

System finds active term for their membershipAccount.

New term is created upon payment with:

renewedFromTermId = priorTermId

startsAt = prior.expiresAt

plan can change (planId differs)

Optionally update membershipAccount.type to match latest plan intent (or derive it).

C) Donation checkout (receipt-only optional)

User enters email for Stripe receipt, chooses Stay anonymous (optional).

System computes any needed flags (campaign/event attribution); does not require creating a contact.

Webhook on success creates transactions:

if stayAnon=true: no contactId, no stored email

else: optionally link to contact (if you later allow opt-in)

Reconciliation and analytics use transactions + campaignId + eventId.

D) Retail checkout (member pricing + receipt-only)

User selects products → creates orders + orderItems (pending).

Checkout collects email for receipt; includes Stay anonymous option.

Pricing logic:

if email corresponds to active membership → member pricing

else non-member pricing

store orders.pricingBasis (member/non_member) for analytics

Webhook on success:

create transactions (kind=retail, link orderId, store Stripe ids)

mark orders.status = paid

if stayAnon=true: do not link order/txn to contact or store email

E) Event check-in (QR + paper)

QR self check-in (identified path)

QR points to /check-in/<eventSlug>?code=<checkInCode>&ref=...

User enters email (creates contact; language from site context).

Create eventAttendances row linked to contact.

Paper tally (anonymous)

Admin records “+10 anonymous attendees”

Create single eventAttendances row with anonymousCount=10 (method=paper).

F) Data export / deletion by email (admin-only)

Lookup contacts by normalized email.

Export related records by traversing:

membershipAccounts (primary/secondaries)

membershipTerms

subscriptions

eventAttendances

(only non-anon) orders/transactions if linked

Anonymize/delete per policy:

keep ledger integrity: transactions typically anonymized (unlink contact, remove any stored PII fields if ever present)

keep attendance totals (unlink contact where needed)

Minimal launch scope knobs (so future-you knows what can be deferred)

ALIASES can be omitted at launch; keep aliasId nullable in eventAttendances and membershipAccounts.aliases for later.

campaigns can start as just refRaw strings; relationship can be added later without breaking flows.

orders can be simplified to “order + items + paid status”; fulfillment/admin live view can come later.